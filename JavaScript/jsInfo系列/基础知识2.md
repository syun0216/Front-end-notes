## chrome之调试

<img src="./img/chrome_debug1.png"/>

## 代码风格

<img src="./img/code.png"/>

总结:
* 对于很短的代码，一行是可以接受的:例如 if (cond) return null .
* 但是括号中的每个语句单独一行通常更好些。

##  使用 mocha 进行自动化测试

describe("title", function() { ... })  

表示我们正在描述的功能是什么。用于组织 “工人(workers)” –   代码块。在我们的例子中我 们正在描述函数   。

it("title", function() { ... })  

it 里面的 “title” 中我们以人类可读的方式描述特定的用例，第二个参数是一个测试它的函数。

assert.equal(value1, value2)

## 开发流程

1. 编写初始规范，测试基本功能
2. 创建一个最出实现
3. 检查它是否工作
4. 现在我们有一个基于测试的能工作的初步实现。
5. 我们增加更多的用例到规范中，或许目前的程序实现还不支持。测试从失败开始。
6. 进行第 3 步，更新程序直到测试不会抛出错误。
7. 重复第 3 步到第 6 步，直到功能完善。

## Babel

当我们使用语言的一些现代特性时，一些引擎可能无法支持这样的代码。  
Babel包含两个部分：
1. transpiler程序，就是重写代码的那个。开发者在自己的电脑上运行。诸如webpack或者brunch这样的现代项目构建系统提供了每次代码改变都会自动运行transpiler方法 
2. polyfill：transpiler会重写代码，但对于新特性我们需要写一个特殊的脚本来实现他们。js是一个高度动态化的语言。脚本可能不仅是添加一些新特性，还会修改一些内置特性，以便于他们表现得符合现代标准。

## Object对象： 基础知识

<img src="./img/keys.png"/>

总结
对象是具有一些特殊特性的关联数组。
他们存储键值对，其中:
* 属性的键必须是字符串或者Symbol(通常是字符串)。
* 值可以是任何类型。
我们可以用下面的方法获取属性:
* 点符号: obj.property 。
* 方括号 obj["property"] ，方括号中可以使用变量 obj[varWithKey] 。 其他操作:
* 删除属性: delete obj.prop。
* 检查属性是否存在: "key" in obj。
* 遍历对象: for(let key in obj) 循环。

对象根据引用来赋值或者复制。换句话说，变量存的不是对象的"值"，而是值的 “引用”(内存地 址)。 所以复制变量或者传递变量到方法中只是复制了对象的引用。 所有的引用操作(像增加， 删除属性)都作用于同一个对象。
深拷贝的话我们可以使用 Object.assign 或者 _.cloneDeep(obj)  。 我们在这一章学习的叫做“基本对象” — 对象。  
JavaScript 中还有很多其他类型的对象:  
 
* Array 存储有序数据集合
* Date 存储时间日期
* Error 存储错误信息

他们有一些特别的特性，我们将在后面学习到。有时候大家说“数组类型”，“时间类型”，他们都属 于对象类型的一种，都以不同的方式对对象类型做了一些扩展。

## 垃圾回收

可达性
JavaScript 中主要的内存管理概念是可达性。 简而言之，『可达』值是那些以某种方式可访问或可用的值。它们保证存储在内存中。
1. 这里列出固有的可达值基本集合，这些值明显不能被释放。
比方说:
* 当前函数的局部变量和参数。
* 嵌套调用时，当前调用链上所有函数的变量与参数。
* 全局变量。
* (还有一些内部的)
这些值被称作根。
2. 如果一个值可以通过引用或引用链，从根值访问到，则认为这个值是可达的。
比方说，如果局部变量中有一个对象，并且该对象具有引用另一个对象的 property，则该对象被 认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。

内部算法
垃圾回收的基本算法被称为 “mark-and-sweep”。 定期执行以下“垃圾回收”步骤:
* 垃圾收集器找到所有的根，并“标记”(记住)它们。  
* 然后它遍历并"标记"来自它们的所有参考。
* 然后它遍历到标记的对象并标记他们的引用。所有被遍历到的对象都会被记住，以免将来再次 遍历到同一个对象。
* ...一直这样，直到有未访问的引用(从根访问到)。
* 没有被标记的所有对象都被删除。

JavaScript引擎做了很多优化，使其运行速度更快，并且不会影响代码运行  

* 分代收集 —— 对象被分成两组:『新的』和『旧的』。许多对象出现，完成他们的工作并快速 释放，他们可以很快被清理。那些长期存活下来的对象会变得『老旧』，而且检查的次数也会 减少。
* 增量收集 —— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时 间并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做，然后将这 几部分逐一处理。这需要他们之间额外的标记来追踪变化，但是会有许多微小的延迟而不是大 的延迟。
* 闲时收集 —— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

总结 主要需要掌握的东西:
* 垃圾回收是自动完成的，我们不能强制执行或是阻止执行。
* 当对象是可达状态时，它在内存中是可达的。
* 被引用与可访问(从一个根)不同:一组相互连接的对象可能整体都无法访问。


## Sysmbol 类型

Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述 只是一个不影响任何东西的标签。

全局 symbol  
正如我们所看到的，通常所有的 Symbol 都是不同的，即使它们有相同的名字。但有时我们想要同  
一个名字的 Symbol 是相同的实体。 比如，我们希望在应用程序的不同部分访问相同的 Symbol "id" 属性 。  
为此，存在一个全局 symbol 注册表。我们可以在其中创建 Symbol 并在稍后访问它们，它可以确 保每次访问相同名称都会返回相同的 Symbol。  
为了在注册表中创建或读取 Symbol，请使用 Symbol.for(key) 。 该调用会检查全局注册表，如果有一个描述为 的 Symbol，则返回该 Symbol，否则将创建一
个新 Symbol( Symbol(key) )，并通过给定的 将其存储在注册表中。 例如:

```js
// 从全局注册表中读取
let id = Symbol.for("id"); // 如果该 Symbol 不存在，则创建它
// 再次读取
let idAgain = Symbol.for("id");
// 相同的 Symbol
alert( id === idAgain ); // true
```

Symbol.keyFor
对于全局 symbol， 不仅按名称返回一个 symbol，而且还有一个反向调用: Symbol.keyFor(sym)，反过来:通过全局 symbol 返回一个名称。

系统Symbol

* Symbol.hasIntance
* Symbol.isConcatSpreadable
* Symbol.iterator
* Symbol.toPromitive

### Symbol总结

Symbol是标识符的基本类型

Symbol使用Symbol创建的，调用带有一个可选描述。
Symbol总是不同的值，即使他们有相同的名称。我们希望同名的Symbol相等，那么我们使用全局注册表；Symbol.for(key)返回一个以key作为名称的全局Symbol， 返回(如果需要的话创建)一个以 key 作为名称的全局 Symbol。 的多次调用完全返回相同的 Symbol。  

Symbol 有两个主要的使用场景:

* 隐藏对象属性。如果需要将属性添加到另一个脚本或库中的对象中，则可以创建Symbol并将其用作属性键。Symbol属性不出现在for...in中，因此不会无心列出。另外它不会被直接访问，因为另一个脚本没有我们的符号，所以它不会不小心干预它的操作。
* JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 访问。我们可以使用Symbol.for(key)Symbol.for它们来改变一些内置行为。例如，在本教程的后面部分，我们将使用Symbol.iterator迭代，Symbol.toPrimitive 来设置对象原始值的转换等等。
* Object.getOwnPropertySymbols(obj) 允许我们获取所有的Symbol。

```js
let obj = {name: "Miro"}
obj[Symbol('age') = 25]
for(let key in obj) {console.log(key)} // name undefined
console.log(obj[Symbol('age')]) // undefined
Object.getOwnPropertySymbols(obj) // [Symbol(age)]
```

## 对象方法与this

总结
* 存储在对象中函数称之为『方法』。
* 对象执行方法进行『操作』，比如 object.doSomething() 。
* 方法可以将该对象引用为 this 。
this 的值是在运行时求值的。
* 函数声明使用的 this 只有等到调用时才会有值。
* 函数可以在对象之间进行共用。
* 当函数使用『方法』语法 object.method() 调用时，调用过程中的 this 总是指向 object 。
请注意箭头函数有些特别:它们没有 this 。在箭头函数内部访问的都是来自外部的 this 值。

### 对象原始值转换
 
Symbol.toPrimitive 我们从第一个方法开始。有一个名为 Symbol.toPrimitive 的内置符号应该用来命名转换方 法，像这样:
```js
obj[Symbol.toPrimitive] = function(hint) {
// 返回一个原始值
// hint = "string"，"number" 和 "default" 中的一个
}
```
```js
let user = { name: "John", money: 1000,
[Symbol.toPrimitive](hint) {
alert(`hint: ${hint}`);
return hint == "string" ? `{name: "${this.name}"}` : this.money;
} };

// 转换演示:
alert(user); // hint: string -> {name: "John"} 
alert(+user); // hint: number -> 1000 
alert(user + 500); // hint: default -> 1500
```

对象到原始值的转换，是由许多内置函数和操作符自动调用的，这些函数使用一个原始值作为返回
值的。
它有三种类型(暗示):
* "string"(对于alert和其他字符转换)
* "number"(对于maths)
* "default"(少数操作)
规范明确描述了哪个操作符使用哪个暗示。极少数操作者“不知道期望什么”并使用 "default" 暗示。通常对于内置对象，"default" 暗示的处理方式与 "number" 相同，因此在实践中最后 两个通常合并在一起。
转换算法是:
1. 调用obj[Symbol.toPrimitive](hint)如果这个方法存在的话，
2. 否则如果暗示是"string"  
  2-1.  尝试obj.toString() 和 obj.valueOf(),无论哪个存在
3. 否则，如果暗示"number"或者"default"  
  3-1. 尝试obj.valueOf() 和 obj.toString() 无论哪个存在。

在实践中，为了记录或调试目的，仅实现 obj.toString() 作为“全捕获"方法通常就够了，这样所有转换都能返回一种“人类可读”的对象表达形式。

### 构造函数和操作符 new

一个函数作为new User(...)执行时，它执行以下步骤：

* 一个新的空对象被创建并分配给this
* 函数体执行。通常它会修改this，并为其添加新的属性。
* 返回this的值

使用new.target来检查它是否被调用

```js
function User(name) {
  if (!new.target) {
    return new User(name)
  }
  this.name = name;
}
```

### 数字类型

在 JavaScript 中，我们通过在数字后附加字母 “e” 来缩短数字，并指定零的数量来计数  
换句话说， "e" 把数字乘以 1 后面跟着指定数量的 0。
换句话说， e 后面的负数表示除以 1 后面跟着给定数量的 0:
```js
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
1e-3 = 1 / 1000 (=0.001)
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

parseInt 和 parseFloat会忽略数字后的字符，而Number和“+”并不会， 例：

```js
+"1000px" // NaN
Number("1000px") // NaN
Number("12.3.4") // NaN
parseInt("1000px") // 1000
parseFloat("12.3.4") // 12.3 the second point stops the reading
```

parseInt(str, radix) 第二个参数指定了数字系统的基础，例：

```js
parseInt('0xff', 16) // 255
parseInt('n9c', 36) // 123456
```

总结：
写入非常大的数字，使用e来代替0  
对于不同进制：
* 可以在十六进制0x，八进制0o和二进制0b系统中直接写入数字
* parseInt(str, base) 解析来自任何数字系统的整数，
* num.toString(base)将数字转换为数字系统中具有给定base的字符串
* 使用 parseInt / parseFloat 进行 软 转换，它从字符串中读取一个数字，然后返回错误发生前可以读取的值。  
分数: 
* 使用Math.floor，Math.ceil，Math.trunc，Math.round 或 num.toFixed(precision)循环。
* 请记住，使用分数时会损失精度。

用于替代indexof(x) !== -1 可以用~运算符既~n的意思跟-(n+1)完全一样，既：
```js
if ([1,2,3].indexOf(4) !== -1)  可以写成
if (~[1,2,3].indexOf(4))
```

es6更推荐使用includes方法

### 获取子字符串
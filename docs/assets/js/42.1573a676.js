(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{340:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("参考"),t("a",{attrs:{href:"https://juejin.im/post/5d48c275f265da03b12032a1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://juejin.im/post/5d48c275f265da03b12032a1"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"自身可枚举属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自身可枚举属性"}},[e._v("#")]),e._v(" 自身可枚举属性")]),e._v(" "),t("p",[e._v("Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列属性和使用for...in循环遍历该对象时返回的顺序一致。如果对象的键值对都不可枚举，那么将返回由键组成的数组。\n这是合理的，因为大多数时间只需要关注对象自身的属性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let simpleColors = {\n  colorA: 'white',\n  colorB: 'black'\n};\nlet natureColor = {\n  colorC: 'green',\n  colorD: 'yellow'\n};\nObject.setPrototypeOf(natureColors, simpleColors);\nObject.keys(natureColors); // => ['colorC', 'colorD']\nnatureColors['colorA']; // white\nnatureColors['colorB']; //black\n")])])]),t("ul",[t("li",[e._v("Object.keys(natureColors)返回natureColors对象的自身可枚举属性键：['colorC'，'colorD']。")]),e._v(" "),t("li",[e._v("natureColors包含从simpleColors原型对象继承的属性，但是Object.keys()函数会跳过它们。")]),e._v(" "),t("li",[e._v("Object.values() 和 Object.entries() 也都是返回一个给定对象自身可枚举属性的键值对数组。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ...\nObject.values(natureColors); \n// => ['green', 'yellow']\nObject.entries(natureColors);\n// => [ ['colorC', 'green'], ['colorD', 'yellow'] ]\n\n")])])]),t("p",[t("strong",[e._v("for...in不仅可以循环枚举还可以枚举原型链中的属性")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let enumerableKeys = [];\nfor(let key in natureColors) {\n  enmerableKeys.push(key);\n}\nenmerableKeys; // => ['colorC', 'colorD', 'colorA', 'colorB']\n")])])]),t("h3",{attrs:{id:"object-values-返回属性值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-values-返回属性值"}},[e._v("#")]),e._v(" Object.values()返回属性值")]),e._v(" "),t("p",[t("strong",[e._v("Object.values方法返回一个给定对象自身的所有可枚举属性值的数组，值的书序与使用for...in循环的顺序相同")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let meals = {\n  mealA: 'Breakfast',\n  mealB: 'Lunch',\n  mealC: 'Dinner'\n}\nfor(let mealName of Object.values(meals)) {\n  console.log(mealName); // 'Breakfast' 'Lunch' 'Dinner'\n}\n")])])]),t("h3",{attrs:{id:"object-entries"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-entries"}},[e._v("#")]),e._v(" Object.entries()")]),e._v(" "),t("p",[t("strong",[e._v("Object.entries()")]),e._v(" 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let meals = {\n  mealA: 'Breakfast',\n  mealB: 'Lunch',\n  mealC: 'Dinner'\n};\nfor (let [key, value] of Object.entries(meals)) {\n  console.log(key + ':' + value);\n}\n// 'mealA:Breakfast' 'mealB:Lunch' 'mealC:Dinner'\n\n")])])]),t("p",[e._v("如上所示，因为 Object.entries()返回一个与数组解构赋值兼容的集合，因此不需要为赋值或声明添加额外的行。"),t("br"),e._v("\n当普通对象要转换成 Map 时Object.entries() 就很有用，因为Object.entries() 返回的格式与Map构造函数接受的格式完全相同：(key,value)。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let greetings = {\n  morning: 'Good morning',\n  midday: 'Good day',\n  evening: 'Good evening'\n};\nlet greetingsMap = new Map(Object.entries(greetings));\ngreetingsMap.get('morning'); // => 'Good morning'\ngreetingsMap.get('midday');  // => 'Good day'\ngreetingsMap.get('evening'); // => 'Good evening'\n\n\n// ...\n[...greetingsMap.values()];\n// => ['Good morning', 'Good day', 'Good evening']\n[...greetingsMap.entries()];\n// => [ ['morning', 'Good morning'], ['midday', 'Good day'], \n//      ['evening', 'Good evening'] ]\n")])])]),t("h3",{attrs:{id:"对象属性的顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象属性的顺序"}},[e._v("#")]),e._v(" 对象属性的顺序")]),e._v(" "),t("ul",[t("li",[e._v("数字：当属性的类型时数字类型时，会按照数字的从大到小的顺序进行排序；")]),e._v(" "),t("li",[e._v("字符串：当属性的类型是字符串时，会按照时间的先后顺序进行排序；")]),e._v(" "),t("li",[e._v("Symbol：当属性的类型是Symbol时，会按照时间的先后顺序进行排序。")])]),e._v(" "),t("p",[e._v("如果需要有序集合，建议将数据存储到数组或set中。")])])}),[],!1,null,null,null);n.default=r.exports}}]);
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP协议 | 前端学习文档</title>
    <meta name="description" content="">
    <link rel="shortcut icon" type="image/x-icon" href="/Front-end-notes/favicon.ico">
    
    <link rel="preload" href="/Front-end-notes/assets/css/0.styles.6f066667.css" as="style"><link rel="preload" href="/Front-end-notes/assets/js/app.2f14803f.js" as="script"><link rel="preload" href="/Front-end-notes/assets/js/2.0a413fad.js" as="script"><link rel="preload" href="/Front-end-notes/assets/js/88.2e824414.js" as="script"><link rel="prefetch" href="/Front-end-notes/assets/js/10.7607303d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/11.ff80616e.js"><link rel="prefetch" href="/Front-end-notes/assets/js/12.ff4f05b2.js"><link rel="prefetch" href="/Front-end-notes/assets/js/13.2cc769db.js"><link rel="prefetch" href="/Front-end-notes/assets/js/14.e32c7245.js"><link rel="prefetch" href="/Front-end-notes/assets/js/15.89fd8a3d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/16.2c2373d8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/17.743bd8b4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/18.405c3f1b.js"><link rel="prefetch" href="/Front-end-notes/assets/js/19.64d6ee72.js"><link rel="prefetch" href="/Front-end-notes/assets/js/20.6e8dc336.js"><link rel="prefetch" href="/Front-end-notes/assets/js/21.c79e987f.js"><link rel="prefetch" href="/Front-end-notes/assets/js/22.7a30d809.js"><link rel="prefetch" href="/Front-end-notes/assets/js/23.755a7c29.js"><link rel="prefetch" href="/Front-end-notes/assets/js/24.e8d63e9b.js"><link rel="prefetch" href="/Front-end-notes/assets/js/25.8517b618.js"><link rel="prefetch" href="/Front-end-notes/assets/js/26.c42d0f9e.js"><link rel="prefetch" href="/Front-end-notes/assets/js/27.3a107f1c.js"><link rel="prefetch" href="/Front-end-notes/assets/js/28.45884464.js"><link rel="prefetch" href="/Front-end-notes/assets/js/29.977837f4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/3.15595de8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/30.169d78f2.js"><link rel="prefetch" href="/Front-end-notes/assets/js/31.dffe1cb9.js"><link rel="prefetch" href="/Front-end-notes/assets/js/32.80b24e8a.js"><link rel="prefetch" href="/Front-end-notes/assets/js/33.95b0426a.js"><link rel="prefetch" href="/Front-end-notes/assets/js/34.07c44226.js"><link rel="prefetch" href="/Front-end-notes/assets/js/35.e9218367.js"><link rel="prefetch" href="/Front-end-notes/assets/js/36.cc16cff2.js"><link rel="prefetch" href="/Front-end-notes/assets/js/37.c640d75f.js"><link rel="prefetch" href="/Front-end-notes/assets/js/38.d23ddc5d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/39.53e42bbe.js"><link rel="prefetch" href="/Front-end-notes/assets/js/4.d64d64db.js"><link rel="prefetch" href="/Front-end-notes/assets/js/40.45865f49.js"><link rel="prefetch" href="/Front-end-notes/assets/js/41.e4d0d70d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/42.c700ee0f.js"><link rel="prefetch" href="/Front-end-notes/assets/js/43.e2754572.js"><link rel="prefetch" href="/Front-end-notes/assets/js/44.58d67420.js"><link rel="prefetch" href="/Front-end-notes/assets/js/45.b6700057.js"><link rel="prefetch" href="/Front-end-notes/assets/js/46.1b48e79d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/47.27bd17db.js"><link rel="prefetch" href="/Front-end-notes/assets/js/48.af243b47.js"><link rel="prefetch" href="/Front-end-notes/assets/js/49.73169f74.js"><link rel="prefetch" href="/Front-end-notes/assets/js/5.145f91c3.js"><link rel="prefetch" href="/Front-end-notes/assets/js/50.da0e41f4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/51.8f558744.js"><link rel="prefetch" href="/Front-end-notes/assets/js/52.c784bbc7.js"><link rel="prefetch" href="/Front-end-notes/assets/js/53.c87e59e6.js"><link rel="prefetch" href="/Front-end-notes/assets/js/54.8f667f21.js"><link rel="prefetch" href="/Front-end-notes/assets/js/55.a709402a.js"><link rel="prefetch" href="/Front-end-notes/assets/js/56.2a775296.js"><link rel="prefetch" href="/Front-end-notes/assets/js/57.cab8f6b0.js"><link rel="prefetch" href="/Front-end-notes/assets/js/58.09c67f73.js"><link rel="prefetch" href="/Front-end-notes/assets/js/59.1cc362b4.js"><link rel="prefetch" href="/Front-end-notes/assets/js/6.0ed80252.js"><link rel="prefetch" href="/Front-end-notes/assets/js/60.4b62cba0.js"><link rel="prefetch" href="/Front-end-notes/assets/js/61.ed3364db.js"><link rel="prefetch" href="/Front-end-notes/assets/js/62.10261f93.js"><link rel="prefetch" href="/Front-end-notes/assets/js/63.222a5cf3.js"><link rel="prefetch" href="/Front-end-notes/assets/js/64.e25f4e03.js"><link rel="prefetch" href="/Front-end-notes/assets/js/65.0109b8ab.js"><link rel="prefetch" href="/Front-end-notes/assets/js/66.e5afac8b.js"><link rel="prefetch" href="/Front-end-notes/assets/js/67.4fea7ba8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/68.b8d4efa2.js"><link rel="prefetch" href="/Front-end-notes/assets/js/69.283f7282.js"><link rel="prefetch" href="/Front-end-notes/assets/js/7.f46554cd.js"><link rel="prefetch" href="/Front-end-notes/assets/js/70.e6089042.js"><link rel="prefetch" href="/Front-end-notes/assets/js/71.195cb99c.js"><link rel="prefetch" href="/Front-end-notes/assets/js/72.7dd73773.js"><link rel="prefetch" href="/Front-end-notes/assets/js/73.0f3ee1f5.js"><link rel="prefetch" href="/Front-end-notes/assets/js/74.bd3dedf5.js"><link rel="prefetch" href="/Front-end-notes/assets/js/75.9c136046.js"><link rel="prefetch" href="/Front-end-notes/assets/js/76.b0d40936.js"><link rel="prefetch" href="/Front-end-notes/assets/js/77.c6427cef.js"><link rel="prefetch" href="/Front-end-notes/assets/js/78.3402afc1.js"><link rel="prefetch" href="/Front-end-notes/assets/js/79.d8f8ad01.js"><link rel="prefetch" href="/Front-end-notes/assets/js/8.82970a73.js"><link rel="prefetch" href="/Front-end-notes/assets/js/80.65221a8f.js"><link rel="prefetch" href="/Front-end-notes/assets/js/81.796e03b8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/82.57341b7a.js"><link rel="prefetch" href="/Front-end-notes/assets/js/83.d985aadb.js"><link rel="prefetch" href="/Front-end-notes/assets/js/84.d4c21519.js"><link rel="prefetch" href="/Front-end-notes/assets/js/85.880bacd2.js"><link rel="prefetch" href="/Front-end-notes/assets/js/86.b6f3f386.js"><link rel="prefetch" href="/Front-end-notes/assets/js/87.dd22bd82.js"><link rel="prefetch" href="/Front-end-notes/assets/js/89.77768d8d.js"><link rel="prefetch" href="/Front-end-notes/assets/js/9.7373e0d8.js"><link rel="prefetch" href="/Front-end-notes/assets/js/90.237dc2cb.js">
    <link rel="stylesheet" href="/Front-end-notes/assets/css/0.styles.6f066667.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Front-end-notes/" class="home-link router-link-active"><!----> <span class="site-name">前端学习文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Front-end-notes/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/Front-end-notes/css/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/Front-end-notes/html/" class="nav-link">HTML</a></div><div class="nav-item"><a href="/Front-end-notes/web/" class="nav-link router-link-active">网络</a></div><div class="nav-item"><a href="/Front-end-notes/project/" class="nav-link">项目构建</a></div><div class="nav-item"><a href="/Front-end-notes/algorithm/" class="nav-link">算法集合</a></div><div class="nav-item"><a href="/Front-end-notes/framework/" class="nav-link">框架</a></div><div class="nav-item"><a href="/Front-end-notes/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/Front-end-notes/books/" class="nav-link">读书笔记</a></div> <a href="https://github.com/syun0216/Front-end-notes" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Front-end-notes/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/Front-end-notes/css/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/Front-end-notes/html/" class="nav-link">HTML</a></div><div class="nav-item"><a href="/Front-end-notes/web/" class="nav-link router-link-active">网络</a></div><div class="nav-item"><a href="/Front-end-notes/project/" class="nav-link">项目构建</a></div><div class="nav-item"><a href="/Front-end-notes/algorithm/" class="nav-link">算法集合</a></div><div class="nav-item"><a href="/Front-end-notes/framework/" class="nav-link">框架</a></div><div class="nav-item"><a href="/Front-end-notes/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/Front-end-notes/books/" class="nav-link">读书笔记</a></div> <a href="https://github.com/syun0216/Front-end-notes" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/Front-end-notes/web/IP十问.html" class="sidebar-link">TCP/IP 十问</a></li><li><a href="/Front-end-notes/web/http笔试.html" class="sidebar-link">http笔试</a></li><li><a href="/Front-end-notes/web/http协议.html" class="active sidebar-link">HTTP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-notes/web/http协议.html#http协议" class="sidebar-link">HTTP协议</a></li><li class="sidebar-sub-header"><a href="/Front-end-notes/web/http协议.html#http的缓存的过程是怎样的？" class="sidebar-link">HTTP的缓存的过程是怎样的？</a></li><li class="sidebar-sub-header"><a href="/Front-end-notes/web/http协议.html#什么时候会触发强缓存或者协商缓存？" class="sidebar-link">什么时候会触发强缓存或者协商缓存？</a></li><li class="sidebar-sub-header"><a href="/Front-end-notes/web/http协议.html#参考" class="sidebar-link">参考</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="http协议"><a href="#http协议" class="header-anchor">#</a> HTTP协议</h2> <h3 id="http有哪些方法"><a href="#http有哪些方法" class="header-anchor">#</a> HTTP有哪些方法</h3> <ul><li><p>1.0：GET、POST和HEAD</p></li> <li><p>1.1：OPTIONS,PUT,DELETE,TRACE和CONNECT</p></li> <li><p>GET: 请求服务器发送某些资源</p></li> <li><p>HEAD: 请求资源的头部信息，并且和GET方法返回的一致。该方法的使用场景是下载大文件前先获取大小再决定是否下载</p></li> <li><p>POST:发送数据给服务器</p></li> <li><p>PUT:用于新增资源或者请求中的有效负载替换目标资源的表现形式</p></li> <li><p>DELETE: 删除指定资源</p></li> <li><p>PATCH: 资源部分修改</p></li> <li><p>CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p></li> <li><p>TRACE:回显服务器收到的请求，主要用于测试或者诊断</p></li></ul> <h3 id="get-post区别"><a href="#get-post区别" class="header-anchor">#</a> GET POST区别</h3> <ul><li>数据传输方式不同：GET请求通过URL传输，POST是请求体</li> <li>安全性不同：POST在请求体有一定安全保障；GET在URL很容易查到数据</li> <li>数据类型不同： GET只允许ASCII字符，POST没有限制</li> <li>GET无害：刷新后退对请求无害，POST可能会重复提交表单</li> <li>特性不同：GET是安全(只读特性，就是不会引起服务器状态变化)且幂等(幂等的概念是指同一个请求方法执行多次和执行一次的效果完全相同)，而post是非安全幂等</li></ul> <h3 id="put和post都是给服务器发送新增资源，区别？"><a href="#put和post都是给服务器发送新增资源，区别？" class="header-anchor">#</a> PUT和POST都是给服务器发送新增资源，区别？</h3> <p>PUT和POST的区别，PUT方式幂等；连续调用多次的效果是相同的，而POST方法是非幂等的。<br>
PUT的uri指向是单一具体的资源，POST可以指向资源集合</p> <p>eg:创建一篇文章如果多次post则会创建多篇；若使用put则修改一次</p> <h3 id="put和patch区别"><a href="#put和patch区别" class="header-anchor">#</a> PUT和PATCH区别</h3> <p>PUT和PATCH都是更新资源，而PATCH可以对资源进行局部更新。比如我们有一篇文章地址 https://www.jianshu.com/articles/1234</p> <div class="language-js extra-class"><pre class="language-js"><code> article <span class="token operator">=</span> <span class="token punctuation">{</span>
   author<span class="token punctuation">:</span> <span class="token string">'123'</span><span class="token punctuation">,</span>
   creationDate<span class="token punctuation">:</span> <span class="token string">'2019-09-01'</span><span class="token punctuation">,</span>
   content<span class="token punctuation">:</span> <span class="token string">'cxk'</span><span class="token punctuation">,</span>
   id<span class="token punctuation">:</span> <span class="token number">1234</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>修改文章作者事发送的数据：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// put</span>
<span class="token punctuation">{</span>
  author<span class="token punctuation">:</span> <span class="token string">'miro'</span><span class="token punctuation">,</span>
  creationDate<span class="token punctuation">:</span> <span class="token string">'2019-09-01'</span><span class="token punctuation">,</span>
  content<span class="token punctuation">:</span> <span class="token string">'cxk'</span><span class="token punctuation">,</span>
  id<span class="token punctuation">:</span> <span class="token number">1234</span>
<span class="token punctuation">}</span>
<span class="token comment">//patch</span>
<span class="token punctuation">{</span>
  author<span class="token punctuation">:</span> <span class="token string">'miro'</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="http的请求报文"><a href="#http的请求报文" class="header-anchor">#</a> http的请求报文</h3> <ul><li>请求行</li> <li>请求头</li> <li>空行</li> <li>请求体</li></ul> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/6bb3600c998901243aa7b3934e5c7ffc.png" alt="2019-06-14-11-24-10"></p> <ul><li>请求行包括：请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET /index.html HTTP/1.1。</li> <li>请求头部:请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔</li></ul> <ol><li>User-Agent：产生请求的浏览器类型。</li> <li>Accept：客户端可识别的内容类型列表。</li> <li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li></ol> <h3 id="http的响应报文"><a href="#http的响应报文" class="header-anchor">#</a> http的响应报文</h3> <ul><li>响应行</li> <li>响应头</li> <li>空行</li> <li>响应体</li></ul> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/1b6f58868e31fb23d0688b8ca0ca619f.png" alt="2019-06-14-11-37-02"></p> <ul><li>响应行： 由协议版本，状态码和状态码的原因短语组成，例如<code>HTTP/1.1 200 OK</code>。</li> <li>响应头：响应部首组成</li> <li>响应体：服务器响应的数据</li></ul> <h3 id="http部首"><a href="#http部首" class="header-anchor">#</a> HTTP部首</h3> <h4 id="通用首部字段-general-header-fields-：请求报文和响应报文都会使用首部"><a href="#通用首部字段-general-header-fields-：请求报文和响应报文都会使用首部" class="header-anchor">#</a> 通用首部字段(General Header Fields)：请求报文和响应报文都会使用首部</h4> <ul><li><strong>Cache-Control 控制缓存</strong></li> <li><strong>Connection连接管理、逐条首部</strong></li> <li>Upgrade升级为其他协议</li> <li>via代理服务器相关信息</li> <li>Wraning错误和警告通知</li> <li>Transfor-Encoding报文主体的传输编码方式</li> <li>Trailer 报文末端的首部一览</li> <li>Prama报文指令</li> <li>Date创建报文日期</li></ul> <h4 id="请求首部字段-request-header-fields-client-2-server-使用的首部"><a href="#请求首部字段-request-header-fields-client-2-server-使用的首部" class="header-anchor">#</a> 请求首部字段(Request Header Fields) client 2 server 使用的首部</h4> <ul><li><strong>Accept客户端或者代理能够处理的媒体类型</strong></li> <li>Accept-Encoding 优先可处理的编码方式</li> <li>Accept-Language 优先可处理的自然语言</li> <li>Accept-Charset 优先可处理的字符集</li> <li>If-Match比较实体标记(ETag)</li> <li>If-None-Match 与If-Match相反</li> <li><strong>If-Modified-Since 比较资源更新时间（Last-Modified）</strong></li> <li><strong>If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反</strong></li> <li>If-Rnages 资源未更新时发送实体byte的范围请求</li> <li><strong>Range 实体的字节范围请求</strong></li> <li><strong>Authorization web的认证信息</strong></li> <li>Proxy-Authorization 代理服务器要求web认证信息</li> <li><strong>Host 请求资源所在服务器</strong></li> <li>From 用户的邮箱地址</li> <li><strong>User-Agent 客户端程序信息</strong></li> <li>Max-Forwrads 最大的逐跳次数</li> <li>TE 传输编码的优先级</li> <li>Referer 请求原始放的url</li> <li>Expect 期待服务器的特定行为</li></ul> <h4 id="响应首部字段-response-header-fields-server-2-client"><a href="#响应首部字段-response-header-fields-server-2-client" class="header-anchor">#</a> 响应首部字段(Response Header Fields) server 2 client</h4> <ul><li>Accept-Ranges 能接受的字节范围</li> <li>Age 推算资源创建经过时间</li> <li><strong>Location 令客户端重定向的URI</strong></li> <li>vary  代理服务器的缓存信息</li> <li><strong>ETag 能够表示资源唯一资源的字符串</strong></li> <li>WWW-Authenticate 服务器要求客户端的验证信息</li> <li>Proxy-Authenticate 代理服务器要求客户端的验证信息</li> <li><strong>Server 服务器的信息</strong></li> <li>Retry-After 和状态码503 一起使用的首部字段，表示下次请求服务器的时间</li></ul> <h4 id="实体首部字段-entiy-header-fields-：针对请求报文和响应报文的实体部分使用首部"><a href="#实体首部字段-entiy-header-fields-：针对请求报文和响应报文的实体部分使用首部" class="header-anchor">#</a> 实体首部字段(Entiy Header Fields)：针对请求报文和响应报文的实体部分使用首部</h4> <ul><li><strong>Allow 资源可支持http请求的方法</strong></li> <li>Content-Language 实体的资源语言</li> <li>Content-Encoding 实体的编码格式</li> <li>Content-Length 实体的大小（字节）</li> <li>Content-Type 实体媒体类型</li> <li>Content-MD5 实体报文的摘要</li> <li>Content-Location 代替资源的yri</li> <li>Content-Rnages 实体主体的位置返回</li> <li><strong>Last-Modified 资源最后的修改资源</strong></li> <li><strong>Expires 实体主体的过期资源</strong></li></ul> <h3 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h3> <p>2xx 成功</p> <ul><li><strong>200 ok 请求正确处理</strong></li> <li>201 Created 请求已经被实现，有一个新资源已经依据请求的需要而建立</li> <li>202 Accepted 请求已被接受，但还没执行，不保证完成</li> <li>204 No content,成功不含实体的主体部分</li> <li><strong>206 Partial Content 进行范围请求</strong></li></ul> <p>3xx 重定向</p> <ul><li>301 moved permanently, 永久重定向，资源已被重新分配了新的url</li> <li><strong>302 found，临时重定向</strong></li> <li>303 see other,资源存在着另一个url</li> <li>304 not modified, 表示服务器允许访问资源，但未满足条件</li> <li>307 temporary redirect 临时重定向，同302</li></ul> <p>4XX 客户端错误</p> <ul><li><strong>400 bad request，请求报文存在语法错误</strong></li> <li><strong>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</strong></li> <li><strong>403 forbidden，表示对请求资源的访问被服务器拒绝</strong></li> <li><strong>404 not found，表示在服务器上没有找到请求的资源</strong></li> <li>408 Request timeout, 客户端请求超时</li> <li>409 Confict, 请求的资源可能引起冲突</li></ul> <p>5XX 服务器错误</p> <ul><li><strong>500 internal sever error，表示服务器端在执行请求时发生了错误</strong></li> <li>501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法</li> <li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li> <li>505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本</li></ul> <h3 id="同样是重定向-307、303、302的区别"><a href="#同样是重定向-307、303、302的区别" class="header-anchor">#</a> 同样是重定向 307、303、302的区别</h3> <p>302是http1.0协议状态码，http1.1细化了302出来303和307。<br>
303明确表示客户端应当采用get方法获取资源，会把post请求变为get请求进行重定向。<br>
307会遵照浏览器标准们不会将post变为get。</p> <h3 id="http-keep-alive"><a href="#http-keep-alive" class="header-anchor">#</a> http keep alive</h3> <p>HTTP1.0中保持长连接在请求头加上Connection:keep-alive</p> <p>keep-alive的优点：</p> <ul><li>较少的CPU和内存的使用（由于同时打开的连接的减少了）</li> <li>允许请求和应答的HTTP管线化</li> <li>降低拥塞控制 （TCP连接减少了）</li> <li>减少了后续请求的延迟（无需再进行握手）</li> <li>报告错误无需关闭TCP连</li></ul> <h3 id="为什么有https"><a href="#为什么有https" class="header-anchor">#</a> 为什么有HTTPS</h3> <p>https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。</p> <h3 id="https是如何保证安全的"><a href="#https是如何保证安全的" class="header-anchor">#</a> HTTPS是如何保证安全的</h3> <p>对称加密：通信双方使用同一个秘钥进行加密，简单性能也好，单无法解决首次发给对方的问题，容易被截获<br>
非对称加密：</p> <ul><li>私钥+公钥=秘钥对</li> <li>即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密</li> <li>因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方</li> <li>然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密</li></ul> <p>解决方案</p> <p>那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。<br>
此时又带来了一个问题，中间人问题：
如果客户端和服务器之间存在一个中间人，这个人只需要把原本双方通信互发的公钥，就可以轻松解密通信双方发送的所有数据<br>
所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。<br>
证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/66bc3fc4f003205c419dd6ada8ae8392.png" alt="2019-06-14-12-30-18"></p> <p>但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。</p> <p>数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。</p> <p>当别人把他的证书发过来的时候,我再用同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者一比,就知道中间有没有被人篡改了。</p> <p>这个时候就能最大程度保证通信的安全了。</p> <h3 id="http2相对于http1-x有什么优势和特点？"><a href="#http2相对于http1-x有什么优势和特点？" class="header-anchor">#</a> HTTP2相对于HTTP1.X有什么优势和特点？</h3> <h4 id="二进制分帧"><a href="#二进制分帧" class="header-anchor">#</a> 二进制分帧</h4> <p>帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。</p> <p>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID</p> <p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</p> <h3 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h3> <p>HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。</p> <ul><li>HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送</li> <li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li> <li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul> <blockquote><p>你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量</p></blockquote> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/33caf22f81643e1ec11f0f46b50e2155.png" alt="2019-06-14-12-52-59"></p> <h3 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> 服务器推送</h3> <p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p> <p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p> <h3 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h3> <p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p> <p>HTTP2中：</p> <ul><li>同域名下所有通信都在单个连接上完成。</li> <li>单个连接可以承载任意数量的双向数据流。</li> <li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装</li></ul> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/823eb09ae4446ba7dc9c06f4e39372e8.png" alt="2019-06-14-12-58-50"></p> <blockquote><p>拓展阅读：<a href="https://zhuanlan.zhihu.com/p/30166894" target="_blank" rel="noopener noreferrer">HTTP/2特性及其在实际应用中的表现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="http的缓存的过程是怎样的？"><a href="#http的缓存的过程是怎样的？" class="header-anchor">#</a> HTTP的缓存的过程是怎样的？</h2> <p>通常情况下的步骤是:</p> <ol><li>客户端向服务器发出请求，请求资源</li> <li>服务器返回资源，并通过响应头决定缓存策略</li> <li>客户端根据响应头的策略决定是否缓存资源（这里假设是），并将响应头与资源缓存下来</li> <li>在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存</li></ol> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/0718a83e37b6ab7d8da67ada5c36834b.png" alt="2019-06-14-19-56-32"></p> <h2 id="什么时候会触发强缓存或者协商缓存？"><a href="#什么时候会触发强缓存或者协商缓存？" class="header-anchor">#</a> 什么时候会触发强缓存或者协商缓存？</h2> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <p>强缓存离不开两个响应头<code>Expires</code>与<code>Cache-Control</code></p> <ul><li>Expires：Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</li></ul> <p><code>Expires: Wed, 11 May 2018 07:20:00 GMT</code></p> <ul><li>Cache-Control: Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间</li></ul> <p><code>Cache-Control: max-age=315360000</code></p> <p>目前主流的做法使用<code>Cache-Control</code>控制缓存，除了<code>max-age</code>控制过期时间外，还有一些不得不提</p> <ul><li>Cache-Control: public可以被所有用户缓存，包括终端和CDN等中间代理服务器</li> <li>Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进行缓存</li> <li>Cache-Control: no-cache,先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使用</li> <li>Cache-Control: no-store，不会产生任何缓存</li></ul> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/b6dfe07b73d4fd62d167e6024d6fa2e1.png" alt="2019-06-15-00-08-57"></p> <p>在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进行协商。</p> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期抑或它的属性设置为no-cache时，那么浏览器第二次请求时就会与服务器进行协商。</p> <p>如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok。</p> <p>服务器判断缓存是否是新鲜的方法就是依靠HTTP的另外两组信息</p> <h4 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="header-anchor">#</a> Last-Modified/If-Modified-Since</h4> <p>客户端首次请求资源时，服务器会把资源的最新修改时间<code>Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT</code>通过响应部首发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头<code>If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT</code>发送给服务器，服务器再跟服务器上的对应资源进行比对，如果服务器的资源更新，那么返回最新的资源，此时状态码200，当服务器资源跟客户端的请求的部首时间一致，证明客户端的资源是最新的，返回304状态码，表示客户端直接用缓存即可。</p> <h4 id="etag-if-none-match"><a href="#etag-if-none-match" class="header-anchor">#</a> ETag/If-None-Match</h4> <p>ETag的流程跟Last-Modified是类似的，区别就在于ETag是根据资源内容进行hash，生成一个信息摘要，只要资源内容有变化，这个摘要就会发生巨变，通过这个摘要信息比对，即可确定客户端的缓存资源是否为最新，这比Last-Modified的精确度要更高。</p> <blockquote><p>响应头</p></blockquote> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/be24a51fb3b4c5052cd4b26010d2789f.png" alt="2019-06-15-00-51-13"></p> <p>因此整体的缓存流程图如下：</p> <p><img src="https://user-images.githubusercontent.com/25027560/38223505-d8ab53da-371d-11e8-9263-79814b6971a5.png" alt="缓存"></p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p><a href="https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/http.md" target="_blank" rel="noopener noreferrer">https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/http.md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/syun0216/Front-end-notes/edit/master//web/http协议.md" target="_blank" rel="noopener noreferrer">在Github上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/7/2019, 3:12:20 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Front-end-notes/web/http笔试.html" class="prev">http笔试</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Front-end-notes/assets/js/app.2f14803f.js" defer></script><script src="/Front-end-notes/assets/js/2.0a413fad.js" defer></script><script src="/Front-end-notes/assets/js/88.2e824414.js" defer></script>
  </body>
</html>

(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{234:function(t,e,n){t.exports=n.p+"assets/img/ct1_1.021760ea.jpeg"},235:function(t,e,n){t.exports=n.p+"assets/img/ct1_2.d39d269b.jpeg"},236:function(t,e,n){t.exports=n.p+"assets/img/ct1_3.76e13d4f.jpeg"},237:function(t,e,n){t.exports=n.p+"assets/img/ct1_4.ba62c951.jpeg"},351:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"第一章-初入react世界"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一章-初入react世界"}},[t._v("#")]),t._v(" 第一章 初入React世界")]),t._v(" "),s("p",[t._v("\b## 重点词汇")]),t._v(" "),s("ul",[s("li",[t._v("专注视图层")])]),t._v(" "),s("blockquote",[s("p",[t._v("React并不是完整的MVC/MVVM框架\b，它专注于提供清晰、简介的view层解决方案。而又和模板引擎不同，因为它又是一个包括view和controller的库。")])]),t._v(" "),s("ul",[s("li",[t._v("Virtual DOM")])]),t._v(" "),s("blockquote",[s("p",[t._v("我们都知道DOM操作非常昂贵。在前端开发中，性能消耗最大的就是DOM操作。"),s("em",[t._v("React把真实DOM树转换成JavaScript对象树，，诶次数据更新后，重新计算Virtual DOM，并和上次生成的VD作对比买对发生变化的部分做批量更新")])])]),t._v(" "),s("ul",[s("li",[t._v("函数式编程")])]),t._v(" "),s("blockquote",[s("p",[t._v("构建一个规则使计算重复被利用。"),s("em",[t._v("React充分利用很多函数式方法减少用于代码。此外它本身就是简单函数，所以易于测试。可以说函数式编程才是React的精髓")])])]),t._v(" "),s("ul",[s("li",[t._v("JSX")])]),t._v(" "),s("blockquote",[s("p",[t._v("jsx的官方定义是类XML语法的ECMAScript扩展。它完美地利用了js自带的语法和特性，并使用大家熟悉的HTML语法来穿件元素。"),s("br"),t._v("\n例如：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  const List = () => (\n    <div>\n      <Title>This is a title</Title>\n      <ul>\n        <li>list item</li>\n        <li>list item</li>\n        <li>list item</li>\n      </ul>\n    </div>\n  )\n")])])]),s("p",[s("font",{attrs:{color:"#ff5858",size:"4"}},[t._v("* 注意：定义标签时，只允许\b被一个标签包裹；标签一定要闭合；定义组件时命名应该使用大写字母开头！！！")])],1),t._v(" "),s("blockquote",[s("p",[t._v("元素属性：js中的class和for均为关键字，"),s("em",[t._v("class->className;for->htmlFor")]),t._v("，boolean属性例如：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<Checkbox checked={true} /> \n// 可以简写为\n<Checkbox checked />\n//反之checked为false就可以省略不写\n<Checkbox checked={false}/>\n//不知道props里与有什么就最好不要设置它，使用es6的rest/spread特性来提高效率\n<Component {...data}>\n")])])]),s("ul",[s("li",[t._v("React组件"),s("br"),t._v("\n代码实例详见p14-p15"),s("br"),t._v("\n1、基本的封装性。\b"),s("br"),t._v("\n2、简单的生命周期呈现 "),s("br"),t._v("\n3、明确的数据流动。根据不同的参数得到\b不同的响应，从而得出不同的渲染结果。")])]),t._v(" "),s("blockquote",[s("p",[t._v("在这个阶段，前端\b在应用级别并没有过多复杂的交互，组件化发展缓慢。这样的逻辑一旦复杂起来，就会存在大量的dom操作，开发和维护成本相当高。")])]),t._v(" "),s("ul",[s("li",[t._v("React组件的构建")])]),t._v(" "),s("blockquote",[s("p",[t._v("React的本质就是关心元素的构成，它基本上由3个部分组成-----属性（props）、状态（state）以及生命周期方法\n"),s("img",{attrs:{src:n(234)}})])]),t._v(" "),s("ul",[s("li",[t._v("React组件的构建方法：1、使用React.createClass构建的组件时React最传统、也是兼容性最好的方法，例子：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const Button = React.createClass({\n  getDefaultProps() {\n    return {\n      color: 'blue',\n      text: 'Confirm'\n    }\n  }\n\n  render() {\n    const {text,color} = this.props;\n    return (\n      <button className={`btn btn-${color}`}>\n        <em>{text}</em>\n      </button>\n    )\n  }\n})\n")])])]),s("p",[t._v("2、ES6 classes")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import React,{Component} from 'react';\nclass Button extends Component {\n  static defaultProps = {\n    color: 'blue',\n    text: 'Confirm'\n  }\n  render() {\n    const {color,text} = this.props;\n    return (\n      <button className={`btn btn-${color}`}>\n        <em>{text}</em>\n      </button>\n    )\n  }\n}\n")])])]),s("blockquote",[s("p",[t._v("在React的开发中，常用的方式是将组件拆分到合理的粒度，用组合的方式合成业务组件，也就是HAS-A关系。")])]),t._v(" "),s("p",[s("font",{attrs:{color:"#ff5858",size:"4"}},[t._v("* React的多有组件都继承自顶层React.Compoennt。它只是初始化了ReactComponent方法，声明了props、context、\brefs等，并在原型上定义了setState和forceUpdate方法。")]),s("br"),t._v("\n3、无状态函数"),s("br")],1),t._v(" "),s("blockquote",[s("p",[t._v("无状态组件之传入props和context两个参数，不存在state，也没有生命周期方法。在适合的情况下，我们都应该切且必须使用无状态组件。")])]),t._v(" "),s("ul",[s("li",[t._v("React的数据流")])]),t._v(" "),s("blockquote",[s("p",[t._v("在React中，数据是自顶向下单向流动的。这条规则让组件之间的关系变得简单可测。")]),t._v(" "),s("ul",[s("li",[t._v("内部的状态同意成为state。值得注意的是，set\bState是一个异步的方法，一个生命周期内所有的setState方法都会结并操作。我们并不推荐开发者滥用state，过多的内部状态会让数据流混乱，程序变得难以维护。")]),t._v(" "),s("li",[t._v("props 是React中用来让组件之间相互联系的的一种机制，就像方法的参数一样。"),s("em",[t._v("对于一个tabs组件它的props会有那些呢，1、className，根节点class方便覆盖原始样式；"),s("br"),t._v("2、classPrefix:class的前缀，对于组件来说，定义一个统一的class前缀，对样式与交互分离起了重要的作用"),s("br"),t._v("3、defaultActiveIndex和activeIndex"),s("br"),t._v("4、onChange：回调函数")]),t._v(" "),s("img",{attrs:{src:n(235)}})]),t._v(" "),s("li",[t._v("子组件prop\n在React中有一个重要且内置的prop-children，它代表组件的子组件合计  p25\n"),s("img",{attrs:{src:n(236)}}),t._v("\n最后TabContent组件的render方法只需要调用getTabPanes方法渲染即可，")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  render() {\n    return (<div>{this.getTabPanes()}</div>)\n  }\n")])])]),s("p",[t._v("这种调用方法叫做动态子组件（Dynamic Children）")]),t._v(" "),s("ul",[s("li",[t._v("组件prop（component prop）"),s("br"),t._v("\n可以将子组件以props的形式传递")]),t._v(" "),s("li",[t._v("用function prop与父组件通信\nthis.props.onChange({activeIndex, preIndex})"),s("br"),t._v("\n父组件将方法传递给子组件，子通过触发onChange给父亲回调需要的值")]),t._v(" "),s("li",[t._v("propTypes\npropTypes用来\b规范props类型的与必须的状态，常见的有（string、number、func、array、bool、oneOfType、node）")])]),t._v(" "),s("h3",{attrs:{id:"react的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react的生命周期"}},[t._v("#")]),t._v(" React的生命周期")]),t._v(" "),s("blockquote",[s("p",[t._v("React的组件的生命周期可以分为挂在、渲染和卸载这几个阶段。大体我们可以分为两类：1、当组件在挂在或卸载时；2、当组件接受新的数据时")])]),t._v(" "),s("ul",[s("li",[t._v("组件的挂载 componentDidMount componentWillMount")]),t._v(" "),s("li",[t._v("组件的卸载 compoentWillUnmount")]),t._v(" "),s("li",[t._v("数据的更新过程")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  class App extends React.Component {\n    componentWillReceiveProps(nextProps) {\n\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n\n    }\n    componentWillUpdate(nextProps,nextState) {\n\n    }\n    componentDidUpdate(prevProps, prevState) {\n\n    }\n  }\n")])])]),s("blockquote",[s("p",[t._v("如果组件发生自身更新那么次执行scu,cwu,render,cdu"),s("br"),t._v("\nshouldComponentUpdate是一个特别的方法，接受props和state让开发者判断其是否需要更新。"),s("br"),t._v(" "),s("font",{attrs:{color:"#ff5858",size:"4"}},[t._v("* 值得注意的是stateless组件没有生命周期方法，也意味着每次都会重新渲染。我们可以使用Recompose库的pure方法：const OptimizedComponent = pure(ExpensiveComponent)")]),s("br")],1)]),t._v(" "),s("h3",{attrs:{id:"整体流程图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整体流程图"}},[t._v("#")]),t._v(" 整体流程图")]),t._v(" "),s("img",{attrs:{src:n(237)}}),t._v("\n- ReactDOM\n主要方法findDOMNode（获取真实dom元素）、render（渲染VirtualDom到dom）、unmountComponentAtNode卸载操作\n")])}),[],!1,null,null,null);e.default=a.exports}}]);
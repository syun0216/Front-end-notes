(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{627:function(v,a,t){"use strict";t.r(a);var _=t(19),r=Object(_.a)({},(function(){var v=this,a=v.$createElement,t=v._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"前端性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[v._v("#")]),v._v(" 前端性能优化")]),v._v(" "),t("h3",{attrs:{id:"动画性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动画性能优化"}},[v._v("#")]),v._v(" 动画性能优化")]),v._v(" "),t("p",[v._v("动画性能的三种主流方式：")]),v._v(" "),t("ul",[t("li",[v._v("Canvas")]),v._v(" "),t("li",[v._v("CSS3")]),v._v(" "),t("li",[v._v("Dom")])]),v._v(" "),t("p",[v._v("dom+js的各种方式由于极易引起浏览器重绘或回流，有非常大性能风险，对于这种动画的优化方法就是不用DOM进行动画操作。")]),v._v(" "),t("h3",{attrs:{id:"css3动画优化原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css3动画优化原理"}},[v._v("#")]),v._v(" CSS3动画优化原理")]),v._v(" "),t("p",[v._v("要想进行css动画优化必须了解一定的浏览器原理，图层、重绘、回流")]),v._v(" "),t("h3",{attrs:{id:"图层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图层"}},[v._v("#")]),v._v(" 图层")]),v._v(" "),t("p",[v._v("浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或者多个节点。在渲染DOM的时候，浏览器所做的实际工作是：")]),v._v(" "),t("ul",[t("li",[v._v("获取dom后分隔为多个图层")]),v._v(" "),t("li",[v._v("对每个图层的节点样式结果(Recalculate style--样式重计算)")]),v._v(" "),t("li",[v._v("为每个节点生成图形和位置(Layout--回流和重布局)")]),v._v(" "),t("li",[v._v("将每个节点回执填充到图层位图中(Paint Setup和Paint--重绘)")]),v._v(" "),t("li",[v._v("图层作为纹理上传至GPU")]),v._v(" "),t("li",[v._v("符合多个图层到页面上生成最终屏幕图像")])]),v._v(" "),t("h3",{attrs:{id:"回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[v._v("#")]),v._v(" 回流")]),v._v(" "),t("p",[v._v("有些节点，当你改变他时，会需要重新布局(重新计算其他被影响的节点的位置和大小)"),t("br"),v._v("\n这种情况下，被影响的DOMtree越大，重绘时间越长，渲染一帧动画的时间也相应变长。"),t("br"),v._v("\n一些常用的改变时会触发重布局的属性。")]),v._v(" "),t("ul",[t("li",[v._v("盒子模型相关属性触发重布局：\n"),t("strong",[v._v("width")]),v._v("、"),t("strong",[v._v("height")]),v._v("、"),t("strong",[v._v("padding")]),v._v("、"),t("strong",[v._v("margin")]),v._v("、"),t("strong",[v._v("display")]),v._v("、"),t("strong",[v._v("border-width")]),v._v("、"),t("strong",[v._v("border")]),v._v("、"),t("strong",[v._v("min-height")])]),v._v(" "),t("li",[v._v("定位属性及浮动也会触发重布局：\n"),t("strong",[v._v("top")]),v._v("、"),t("strong",[v._v("bottom")]),v._v("、"),t("strong",[v._v("left")]),v._v("、"),t("strong",[v._v("right")]),v._v("、"),t("strong",[v._v("position")]),v._v("、"),t("strong",[v._v("float")]),v._v("、"),t("strong",[v._v("clear")])]),v._v(" "),t("li",[v._v("改变节点内部文字结构也会触发重布局：\n"),t("strong",[v._v("text-align")]),v._v("、"),t("strong",[v._v("overflow-y")]),v._v("、"),t("strong",[v._v("font-weight")]),v._v("、"),t("strong",[v._v("overflow")]),v._v("、"),t("strong",[v._v("font-family")]),v._v("、"),t("strong",[v._v("line-height")]),v._v("、"),t("strong",[v._v("vertical-align")]),v._v("、"),t("strong",[v._v("white-space")]),v._v("、"),t("strong",[v._v("font-size")])])]),v._v(" "),t("h3",{attrs:{id:"重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[v._v("#")]),v._v(" 重绘")]),v._v(" "),t("p",[v._v("修改时只触发重绘的属性有：")]),v._v(" "),t("ul",[t("li",[v._v("color")]),v._v(" "),t("li",[v._v("border-style")]),v._v(" "),t("li",[v._v("border-radius")]),v._v(" "),t("li",[v._v("visibility")]),v._v(" "),t("li",[v._v("text-decoration")]),v._v(" "),t("li",[v._v("background")]),v._v(" "),t("li",[v._v("background-image")]),v._v(" "),t("li",[v._v("background-position")]),v._v(" "),t("li",[v._v("background-repeat")]),v._v(" "),t("li",[v._v("background-size")]),v._v(" "),t("li",[v._v("outline-color")]),v._v(" "),t("li",[v._v("outline")]),v._v(" "),t("li",[v._v("outline-style")]),v._v(" "),t("li",[v._v("outline-width")]),v._v(" "),t("li",[v._v("box-shadow")])]),v._v(" "),t("p",[v._v("这些属性都不会修改节点的大小和位置，只需要内部重绘不需要节点重排。")]),v._v(" "),t("h2",{attrs:{id:"css3动画优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css3动画优化"}},[v._v("#")]),v._v(" CSS3动画优化")]),v._v(" "),t("p",[v._v("遵循原则：")]),v._v(" "),t("ul",[t("li",[v._v("尽量将动画放在一个独立的图层，这样可以避免动画效果影响其他渲染层的元素")]),v._v(" "),t("li",[v._v("尽量避免回流和重绘")]),v._v(" "),t("li",[v._v("尽量使用GPU，速度更快")])]),v._v(" "),t("h3",{attrs:{id:"如何创建合成层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何创建合成层"}},[v._v("#")]),v._v(" 如何创建合成层")]),v._v(" "),t("p",[v._v("直接原因：")]),v._v(" "),t("ul",[t("li",[v._v("硬件加速的iframe元素")]),v._v(" "),t("li",[v._v("video元素")]),v._v(" "),t("li",[v._v("覆盖在video元素上的视频控制栏")]),v._v(" "),t("li",[v._v("3D或者硬件加速的2D Canvas元素\n"),t("ul",[t("li",[v._v("demo：普通2D Canvas不会提升为合成层")]),v._v(" "),t("li",[v._v("demo：3D Canvas提升为合成层")])])]),v._v(" "),t("li",[v._v("硬件加速的插件，比如flash")]),v._v(" "),t("li",[v._v("DPI较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶")]),v._v(" "),t("li",[v._v("有 3D transform")]),v._v(" "),t("li",[v._v("backface-visibility 为 hidden")]),v._v(" "),t("li",[v._v("对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）")]),v._v(" "),t("li",[v._v("will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）demo")]),v._v(" "),t("li",[v._v("后代元素原因:\n"),t("ul",[t("li",[v._v("有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 demo")]),v._v(" "),t("li",[v._v("有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） demo")]),v._v(" "),t("li",[v._v("有合成层后代同时本身 fixed 定位 demo")]),v._v(" "),t("li",[v._v("有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 demo")]),v._v(" "),t("li",[v._v("有 3D transfrom 的合成层后代同时本身有 perspective 属性 demo")])])])]),v._v(" "),t("p",[v._v("提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。")]),v._v(" "),t("h3",{attrs:{id:"如何避免回流和重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何避免回流和重绘"}},[v._v("#")]),v._v(" 如何避免回流和重绘")]),v._v(" "),t("p",[v._v("多使用transform和opacity实现动画效果，不会导致回流和重绘")]),v._v(" "),t("h3",{attrs:{id:"如何利用gpu进行加速"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何利用gpu进行加速"}},[v._v("#")]),v._v(" 如何利用GPU进行加速")]),v._v(" "),t("ul",[t("li",[v._v("Canvas+JavaScript: 实现复杂可控动画")]),v._v(" "),t("li",[v._v("运用requestAnimationFrame\n"),t("ul",[t("li",[v._v("性能更好: 优点是它能够将所有的动画都放到一个浏览器重绘周期里去做，这样能保存你的CPU的循环次数,提高性能")]),v._v(" "),t("li",[v._v("开销更小: requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销")])])])]),v._v(" "),t("h3",{attrs:{id:"离屏canvas"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#离屏canvas"}},[v._v("#")]),v._v(" 离屏Canvas")]),v._v(" "),t("p",[v._v("离屏渲染的原理是把离屏 canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用 canvas的 API的消耗:")]),v._v(" "),t("ul",[t("li",[v._v("创建离屏canvas")]),v._v(" "),t("li",[v._v("设置宽高")]),v._v(" "),t("li",[v._v("在离屏canvas中进行绘制")]),v._v(" "),t("li",[v._v("在离屏canvas的全部或者部分绘制到正在显示的canvas上")])]),v._v(" "),t("h3",{attrs:{id:"避免浮点运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#避免浮点运算"}},[v._v("#")]),v._v(" 避免浮点运算")]),v._v(" "),t("p",[v._v("利用canvas进行画绘制时，如果计算出来的坐标是浮点数，那么可能会出现css sub-pixel问题，也就是会自动浮点数四舍五入转为整数。这可能会出现抖动的情况，同事也可能在元素的边缘出现锯齿失真。")]),v._v(" "),t("h3",{attrs:{id:"减少调用canvas-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#减少调用canvas-api"}},[v._v("#")]),v._v(" 减少调用canvas Api")]),v._v(" "),t("p",[v._v("canvas也是通过js来绘制，canvas api更加消耗资源，适量js原生计算减少canvas api的调用是一件比较划算的事情。")]),v._v(" "),t("p",[v._v("粒子效果：尽量少使用圆形，而使用正方形")]),v._v(" "),t("h3",{attrs:{id:"web-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#web-worker"}},[v._v("#")]),v._v(" web worker")]),v._v(" "),t("p",[v._v("web worker最常用的场景就是大量的频繁的计算，减轻主线程压力，如果遇到大规模的dom操作等，可以通过此api分担主线程压力，此api兼容性已经不错了，canvas可以用，那web worker也可以考虑使用")]),v._v(" "),t("h2",{attrs:{id:"大量数据性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大量数据性能优化"}},[v._v("#")]),v._v(" 大量数据性能优化")]),v._v(" "),t("h3",{attrs:{id:"虚拟列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表"}},[v._v("#")]),v._v(" 虚拟列表")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/17fb2b15b40f4dcde54a42623e2ac67e.png",alt:"2019-08-10-00-16-58"}})]),v._v(" "),t("blockquote",[t("p",[v._v("虚拟滚动的具体实现原理可以参看饿了么前端的文章"),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34585166",target:"_blank",rel:"noopener noreferrer"}},[v._v("再谈前端虚拟列表的实现"),t("OutboundLink")],1)])]),v._v(" "),t("h3",{attrs:{id:"web-worker-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#web-worker-2"}},[v._v("#")]),v._v(" web worker")]),v._v(" "),t("p",[v._v("Web Worker 是一个独立的线程（独立的执行环境），这就意味着它可以完全和 UI 线程（主线程）并行的执行 js 代码，从而不会阻塞 UI，它和主线程是通过 onmessage 和 postMessage 接口进行通信的。"),t("br"),v._v("\nWeb Worker 使得网页中进行多线程编程成为可能。当主线程在处理界面事件时，worker 可以在后台运行，帮你处理大量的数据计算，当计算完成，将计算结果返回给主线程，由主线程更新 DOM 元素。")]),v._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/execute.md",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/execute.md"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);